{"mode":"Text","hardwareTarget":"brain","textContent":"import math\nimport random\nfrom vexcode_vr import *\n\nbrain = Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6) \ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9) \n\n# ------------------------------------------\n# \tProject:      VEXcode Project\n#\tAuthor:       David Ani\n#\tDescription:  Pathfinding in a maze using recorded coordinates\n# ------------------------------------------\n\nfrom vexcode import *\nfrom collections import deque\n\n# Function to move the robot to a specific (x, y) location\ndef move(x_loc, y_loc):\n    # Calculate the difference in x and y coordinates\n    b = x_loc - location.position(X, MM)\n    c = y_loc - location.position(Y, MM)\n\n    # If there's no movement needed, skip the move\n    if b == 0 and c == 0:\n        pass\n    else:\n        # Calculate the Euclidean distance\n        a = math.sqrt(b**2 + c**2)\n        \n        # Calculate the angle to turn towards the destination\n        angle = math.asin((math.sin(math.pi / 2) * b) / a) / math.pi * 180\n        \n        # Adjust the angle if needed based on the direction\n        if c < 0:\n            angle = 180 - angle\n        \n        # Turn the robot to the calculated angle and move\n        drivetrain.turn_to_heading(angle, DEGREES)\n        drivetrain.drive_for(FORWARD, a, MM)\n\n# Function to draw the maze in the console\ndef draw_maze(coords_list):\n    resolution = 25\n\n    # Determine the bounds of the maze\n    min_x = min(x for x, y in coords_list)\n    max_x = max(x for x, y in coords_list)\n    min_y = min(y for x, y in coords_list)\n    max_y = max(y for x, y in coords_list)\n\n    # Calculate grid dimensions on the bounds and resolution\n    grid_width = (max_x - min_x) // resolution + 1\n    grid_height = (max_y - min_y) // resolution + 1\n\n    # grid with walls\n    grid = [[\"#\" for _ in range(grid_width)] for _ in range(grid_height)]\n\n    # Mark a specific position on the grid with a symbol\n    def mark_path(x, y, symbol=\"o\"):\n        grid_x = (x - min_x) // resolution\n        grid_y = (y - min_y) // resolution\n        grid[grid_y][grid_x] = symbol\n\n    # Mark the start ('S') and end ('E') positions\n    mark_path(coords_list[0][0], coords_list[0][1], \"S\")  \n    mark_path(coords_list[-1][0], coords_list[-1][1], \"E\")  \n\n    # Mark the path taken (each step between coordinates)\n    for i in range(1, len(coords_list)):\n        x1, y1 = coords_list[i - 1]\n        x2, y2 = coords_list[i]\n\n        # Calculate the steps needed to draw the line between points\n        steps = max(abs(x2 - x1), abs(y2 - y1)) // resolution\n        for step in range(steps + 1):\n            interp_x = x1 + (x2 - x1) * step // steps\n            interp_y = y1 + (y2 - y1) * step // steps\n            mark_path(interp_x, interp_y, \".\")\n\n\n    brain.print(\"\\n\".join(\"\".join(row) for row in reversed(grid)))\n\ndef main():\n    # Set up the pen color and position\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n\n    # Initialize coordinates list to store the robot's path\n    cords_list = []\n\n    # Set the drivetrain velocity for movement\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    # Turn the robot to the right by 90 degrees to start the exploration\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    \n    # Add the starting coordinates to the path list\n    cords_list.append([location.position(X, MM), location.position(Y, MM)])\n\n    # Start the maze exploration\n    while not down_eye.detect(RED):  # Stop when the red color is detected\n        if front_distance.get_distance(MM) > 260:\n            drivetrain.drive_for(FORWARD, 250, MM) \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n            # Check if the robot is revisiting a previously visited spot and avoid unnecessary movement\n            if cords_list[len(cords_list) - 2][0] < location.position(X, MM) + 5 and cords_list[len(cords_list) - 2][0] > location.position(X, MM) - 5 and cords_list[len(cords_list) - 2][1] < location.position(Y, MM) + 5 and cords_list[len(cords_list) - 2][1] > location.position(Y, MM) - 5:\n                cords_list.pop()\n                cords_list.pop()  # Remove last added coordinate\n\n            # Append the current coordinates to the path list\n            cords_list.append([location.position(X, MM), location.position(Y, MM)])\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)  # If there's an obstacle, turn left\n\n        wait(5, MSEC)\n\n\n    pen.set_pen_color(BLACK)\n    pen.move(DOWN)\n\n    # Reverse the coordinate list\n    cords_list.reverse()\n\n    # Move the robot along the recorded path\n    for i in range(len(cords_list)):\n        move(cords_list[i][0], cords_list[i][1])\n\n    # Draw the maze in the console\n    draw_maze(cords_list)\n    \nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}